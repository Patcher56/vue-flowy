{"version":3,"file":"FlowChart.js","sources":["../src/FlowElement.ts","../src/Graph.ts","../src/render/label.ts","../src/render/shapes.ts","../src/render/nodes.ts","../src/layout/rank/util.ts","../src/layout/rank/feasible-tree.ts","../src/algorithms/dfs.ts","../src/algorithms/postorder.ts","../src/layout/rank/network-simplex.ts","../src/layout/rank.ts","../src/layout/util.ts","../src/layout/order/initOrder.ts","../src/layout/order.ts","../src/layout/position.ts","../src/layout.ts","../src/Renderer.ts","../src/FlowChart.ts"],"sourcesContent":["import { FlowChartElementOptions } from './FlowChart';\n\nexport interface FlowElementEdgeOptions {\n  label?: string\n}\n\nexport interface FlowElementEdge {\n  otherId: string\n  options?: FlowElementEdgeOptions\n}\n\nexport interface FlowElementListener {\n  event: string\n  callback: () => void\n}\n\nexport const flowElementsById: Record<string, FlowElement> = {}\n\nexport class FlowElement {\n  id: string\n  options: FlowChartElementOptions\n  edges: FlowElementEdge[] = []\n  listeners: FlowElementListener[] = []\n\n  constructor(id: string, options?: FlowChartElementOptions) {\n    this.id = id\n    this.options = Object.assign({}, options)\n    this.register()\n  }\n\n  static getById(id: string) {\n    return flowElementsById[id]\n  }\n\n  leadsTo(destinationElement: FlowElement, options?: FlowElementEdgeOptions) {\n    this.edges.push({otherId: destinationElement.id, options})\n    return destinationElement\n  }\n\n  unregister() {\n    delete flowElementsById[this.id]\n  }\n\n  private register() {\n    if (flowElementsById[this.id]) {\n      throw new Error('ID ' + this.id + 'is already registered!')\n    }\n\n    flowElementsById[this.id] = this\n  }\n\n  on(event: string, callback: () => void) {\n    this.listeners.push({event, callback})\n  }\n}","import { BaseType } from \"d3\"\n\ninterface GraphOptions {\n  directed?: boolean\n  multigraph?: boolean\n  compound?: boolean\n}\n\nexport interface GraphObject {\n  rankdir: 'LR' | 'TB' | 'BT' | 'RL'\n  marginx?: number\n  marginy?: number\n  ranker?: 'network-simplex' | 'tight-tree' | 'longest-path'\n}\n\nexport interface NodeOptions {\n  label?: string\n  shape?: 'rect' | 'circle'\n  rx?: number\n  ry?: number\n}\n\nexport interface InternalNodeOptions<T extends string> {\n  id: T\n  width: number\n  height: number\n  x: number\n  y: number\n  padding: {\n    left: number\n    right: number\n    top: number\n    bottom: number\n  },\n  parent?: T\n  children: Record<string, any>\n  inEdges: Record<string, Edge<T>>\n  outEdges: Record<string, Edge<T>>\n  predecessors: Record<string, Record<T, any>>\n  successors: Record<string, Record<T, any>>\n  labelType: 'svg' | 'html' | 'text'\n  svg?: BaseType\n  rank?: number\n  order: number\n  low?: number\n  lim?: number\n}\n\nexport type Node<T extends string> = NodeOptions & InternalNodeOptions<T>\n\nexport interface EdgeOptions {\n  label?: string\n}\n\ninterface InternalEdgeOptions<T extends string> {\n  fromId: T\n  toId: T\n  minlen: number\n  weight: number\n  cutvalue?: number\n}\n\ntype Edge<T extends string> = EdgeOptions & InternalEdgeOptions<T>\n\nconst delimiter = '\\x01'\n\nfunction edgeArgsToId<T extends string>(directed: boolean, fromId: T, toId: T, name?: string) {\n  if (!directed && fromId > toId) {\n    const tmp = fromId;\n    fromId = toId;\n    toId = fromId;\n  }\n\n  return fromId + delimiter + toId + delimiter + (name || '')\n}\n\nexport default class Graph<T extends string> {\n  public directed: boolean\n  private compound: boolean\n\n  public graph?: GraphObject\n  public nodes = {} as Record<T, Node<T>>\n  private edges: Record<string, Edge<T>> = {}\n\n  constructor(options?: GraphOptions) {\n    this.directed = options?.directed ?? false\n    this.compound = options?.compound ?? false\n  }\n\n  setGraph(graph: GraphObject) {\n    this.graph = graph\n    return this\n  }\n\n  setNode(id: T, options: NodeOptions) {\n    const defaultOptions: InternalNodeOptions<T> = {\n      id,\n      x: 0,\n      y: 0,\n      width: 10,\n      height: 10,\n      padding: {\n        left: 10,\n        right: 10,\n        top: 10,\n        bottom: 10\n      },\n      children: {},\n      inEdges: {},\n      outEdges: {},\n      predecessors: {},\n      successors: {},\n      labelType: 'text',\n      order: 0\n    }\n\n    this.nodes[id] = Object.assign(defaultOptions, options)\n    return this\n  }\n\n  node(id: T) {\n    return this.nodes[id]\n  }\n\n  hasNode(id: T) {\n    return this.nodes[id] !== undefined\n  }\n\n  get nodeIds() {\n    return Object.keys(this.nodes) as Array<T>\n  }\n\n  get nodeObjects() {\n    return Object.values<Node<T>>(this.nodes)\n  }\n\n  setEdge(fromId: T, toId: T, options: EdgeOptions) {\n    const id = this.createEdgeId(fromId, toId)\n\n    const fromNode = this.node(fromId)\n    const toNode = this.node(toId)\n\n    const defaultOptions: InternalEdgeOptions<T> = {\n      fromId,\n      toId,\n      minlen: 0,\n      weight: 1\n    }\n\n    const edgeObject = Object.assign(defaultOptions, options)\n\n    fromNode.outEdges[id] = edgeObject\n    toNode.inEdges[id] = edgeObject\n\n    this.edges[id] = edgeObject\n  }\n\n  edge(childId: T, parentId: T, name?: string) {\n    const edgeId = edgeArgsToId(this.directed, childId, parentId, name)\n    return this.edges[edgeId]\n  }\n\n  get edgeIds() {\n    return Object.keys(this.edges)\n  }\n\n  get edgeObjects() {\n    return Object.values(this.edges)\n  }\n\n  inEdgeObjects(id: T, fromId?: T) {\n    const inEdges = this.nodes[id].inEdges\n\n    if (!inEdges) {\n      return []\n    }\n\n    const inEdgeObjects = Object.values(inEdges)\n\n    if (!fromId) {\n      return inEdgeObjects\n    }\n\n    return inEdgeObjects.filter(edge => edge.fromId === fromId)\n  }\n\n  outEdgeObjects(id: T, toId?: T) {\n    const outEdges = this.nodes[id].outEdges\n\n    if (!outEdges) {\n      return []\n    }\n\n    const outEdgeObjects = Object.values(outEdges)\n\n    if (!toId) {\n      return outEdgeObjects\n    }\n\n    return outEdgeObjects.filter(edge => edge.toId === toId)\n  }\n\n  nodeEdgeObjects(fromId: T, toId?: T) {\n    const inEdges = this.inEdgeObjects(fromId, toId)\n    const outEdges = this.outEdgeObjects(fromId, toId)\n\n    return inEdges.concat(outEdges)\n  }\n\n  hasEdge(fromId: T, toId: T, name?: string) {\n    const edgeId = edgeArgsToId(this.directed, fromId, toId, name)\n    return this.edges[edgeId] !== undefined\n  };\n\n  predecessors(id: T) {\n    const nodes = this.node(id).predecessors\n    return Object.keys(nodes) as T[]\n  }\n\n  successors(id: T) {\n    const nodes = this.node(id).successors\n    return Object.keys(nodes) as T[]\n  }\n\n  neighbors(id: T) {\n    const predecessors = this.predecessors(id)\n    const successors = this.successors(id)\n\n    return predecessors.concat(successors)\n  }\n\n  get rootNodeIds() {\n    return this.nodeIds.filter(id => Object.keys(this.node(id).inEdges).length === 0)\n  }\n\n  createEdgeId<F, To>(fromId: F, toId: To) {\n    return fromId + delimiter + toId\n  }\n}","import { Node } from \"@/Graph\";\nimport { Selection } from \"d3-selection\";\nimport { SVGGElementSelection } from \"@/types/d3-extra\";\n\nexport function addLabel<T extends string>(labelGroup: SVGGElementSelection, node: Node<T>) {\n  const labelText = node.label\n  const svg = labelGroup.append('g')\n\n  switch (node.labelType) {\n    case 'text':\n      addTextLabel(svg, node)\n      break;\n    default:\n      throw new Error(`Node label type ${node.labelType} is not implemented!`)\n  }\n\n  const labelBBox = svg.node()!.getBBox()\n  const y = (-labelBBox.height / 2)\n\n  svg.attr('transform', `translate(${-labelBBox.width / 2},${y})`)\n\n  return svg\n}\n\nfunction addSvgLabel<T extends string>(svg: SVGGElementSelection, node: Node<T>) {\n  // svg.node()?.appendChild(node.label!)\n}\n\nfunction addTextLabel<T extends string>(svg: SVGGElementSelection, node: Node<T>) {\n  const textSvg = svg.append('text')\n\n  const lines = processEscapeSequences(node.label!).split('\\n')\n  for (const line of lines) {\n    textSvg.append('tspan')\n      .attr('xml:space', 'preserve')\n      .attr('dy', '1em')\n      .attr('x', '1')\n      .text(line)\n  }\n\n  return textSvg\n}\n\nfunction processEscapeSequences(text: string) {\n  var newText = \"\";\n  var escaped = false;\n  var ch;\n  for (var i = 0; i < text.length; ++i) {\n    ch = text[i];\n    if (escaped) {\n      switch(ch) {\n      case \"n\": newText += \"\\n\"; break;\n      default: newText += ch;\n      }\n      escaped = false;\n    } else if (ch === \"\\\\\") {\n      escaped = true;\n    } else {\n      newText += ch;\n    }\n  }\n  return newText;\n}","// source: https://github.com/dagrejs/dagre-d3/blob/master/lib/shapes.js\n\n// const intersectRect = require(\"./intersect/intersect-rect\");\n// const intersectEllipse = require(\"./intersect/intersect-ellipse\");\n// const intersectCircle = require(\"./intersect/intersect-circle\");\n// const intersectPolygon = require(\"./intersect/intersect-polygon\");\n\nimport {Node} from '../Graph'\nimport {BaseTypeSelection} from '../types/d3-extra'\n\nexport function rect(parent: BaseTypeSelection, bbox: DOMRect, node: Node<string>) {\n  var shapeSvg = parent.insert(\"rect\", \":first-child\")\n    .attr(\"rx\", node.rx || 0)\n    .attr(\"ry\", node.ry || 0)\n    .attr(\"x\", -bbox.width / 2)\n    .attr(\"y\", -bbox.height / 2)\n    .attr(\"width\", bbox.width)\n    .attr(\"height\", bbox.height);\n\n  // node.intersect = function(point) {\n  //   return intersectRect(node, point);\n  // };\n\n  return shapeSvg;\n}\n\nexport function ellipse(parent: BaseTypeSelection, bbox: DOMRect, node: Node<string>) {\n  var rx = bbox.width / 2;\n  var ry = bbox.height / 2;\n  var shapeSvg = parent.insert(\"ellipse\", \":first-child\")\n    .attr(\"x\", -bbox.width / 2)\n    .attr(\"y\", -bbox.height / 2)\n    .attr(\"rx\", rx)\n    .attr(\"ry\", ry);\n\n  // node.intersect = function(point) {\n  //   return intersectEllipse(node, rx, ry, point);\n  // };\n\n  return shapeSvg;\n}\n\nexport function circle(parent: BaseTypeSelection, bbox: DOMRect, node: Node<string>) {\n  var r = Math.max(bbox.width, bbox.height) / 2;\n  var shapeSvg = parent.insert(\"circle\", \":first-child\")\n    .attr(\"x\", -bbox.width / 2)\n    .attr(\"y\", -bbox.height / 2)\n    .attr(\"r\", r);\n\n  // node.intersect = function(point) {\n  //   return intersectCircle(node, r, point);\n  // };\n\n  return shapeSvg;\n}\n\n// Circumscribe an ellipse for the bounding box with a diamond shape. I derived\n// the function to calculate the diamond shape from:\n// http://mathforum.org/kb/message.jspa?messageID=3750236\nexport function diamond(parent: BaseTypeSelection, bbox: DOMRect, node: Node<string>) {\n  var w = (bbox.width * Math.SQRT2) / 2;\n  var h = (bbox.height * Math.SQRT2) / 2;\n  var points = [\n    { x:  0, y: -h },\n    { x: -w, y:  0 },\n    { x:  0, y:  h },\n    { x:  w, y:  0 }\n  ];\n  var shapeSvg = parent.insert(\"polygon\", \":first-child\")\n    .attr(\"points\", points.map(function(p) { return p.x + \",\" + p.y; }).join(\" \"));\n\n  // node.intersect = function(p) {\n  //   return intersectPolygon(node, points, p);\n  // };\n\n  return shapeSvg;\n}\n","import { AnySelection } from \"@/types/d3-extra\"\nimport Graph from \"@/Graph\"\nimport { select } from \"d3-selection\"\nimport { addLabel } from \"./label\"\nimport * as shapes from './shapes'\n\nexport function createNodes<T extends string>(selection: AnySelection, graph: Graph<T>) {\n  let nodeGroups = selection.selectAll(\"g.node\").data(graph.nodeIds, (k: any) => k)\n  nodeGroups.enter().append('g').attr('class', 'node')\n\n  // I do not exactly know why we have to select them again now. \n  nodeGroups = selection.selectAll(\"g.node\")\n\n  nodeGroups.each(function(id) {\n    const node = graph.node(id)\n    const group = select(this)\n\n    const labelGroup = group.append('g').attr('class', 'label')\n    const labelSvg = addLabel(labelGroup, node)\n    const bbox = labelSvg.node()!.getBBox()\n    const shape = shapes[node.shape || 'rect']\n\n    node.svg = this\n\n    bbox.width += node.padding.left + node.padding.right\n    bbox.height += node.padding.top + node.padding.bottom\n    labelGroup.attr('transform', `translate(${((node.padding.left - node.padding.right) / 2)},${((node.padding.top - node.padding.bottom) / 2)})`)\n\n    const shapeSvg = shape(group, bbox, node)\n\n    const shapeBBox = shapeSvg.node()?.getBBox()\n    node.width = shapeBBox!.width\n    node.height = shapeBBox!.height\n  })\n\n  return nodeGroups\n}\n\nexport function positionNodes<T extends string>(selection: AnySelection, graph: Graph<T>) {\n  function translate(id: T) {\n    const node = graph.node(id)\n    return `translate(${node.x},${node.y})`\n  }\n\n  selection.attr('transform', translate)\n}","import Graph from '../../Graph'\n\n/*\n * Initializes ranks for the input graph using the longest path algorithm. This\n * algorithm scales well and is fast in practice, it yields rather poor\n * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom\n * ranks wide and leaving edges longer than necessary. However, due to its\n * speed, this algorithm is good for getting an initial ranking that can be fed\n * into other algorithms.\n *\n * This algorithm does not normalize layers because it will be used by other\n * algorithms in most cases. If using this algorithm directly, be sure to\n * run normalize at the end.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG.\n *    2. Input graph node labels can be assigned properties.\n *\n * Post-conditions:\n *\n *    1. Each node will be assigned an (unnormalized) \"rank\" property.\n */\nexport function longestPath<T extends string>(graph: Graph<T>) {\n  const visited = {} as Record<T, true>\n\n  function dfs(id: T) {\n    const node = graph.node(id)\n\n    if (visited[id]) {\n      return node.rank!;\n    }\n\n    visited[id] = true;\n\n    let rank = Math.min(...graph.outEdgeObjects(id).map(edge => dfs(edge.toId) - edge.minlen))\n\n    console.log('new rank for node', id, rank)\n\n    if (rank === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3\n        rank === undefined || // return value of _.map([]) for Lodash 4\n        rank === null) { // return value of _.map([null])\n      rank = 0;\n    }\n\n    return (node.rank = rank);\n  }\n\n  console.log('root nodes', graph.rootNodeIds)\n\n  for (const id of graph.rootNodeIds) {\n    dfs(id)\n  }\n}","import Graph from \"@/Graph\";\n\nexport function feasibleTree<T extends string>(graph: Graph<T>) {\n  const t = new Graph({directed: false})\n\n  const start = graph.nodeIds[0]\n  const size = graph.nodeIds.length\n  t.setNode(start, {})\n\n  // TODO!\n\n  return t\n}","import Graph from '../Graph'\n\nfunction doDfs<T extends string>(graph: Graph<T>, id: T, postorder: boolean, visited: Record<T, true>, navigation: Function, acc: T[]) {\n  if (visited[id]) {\n    return\n  }\n\n  visited[id] = true\n\n  if (!postorder) {\n    acc.push(id)\n  }\n\n  for (const i of navigation(id)) {\n    doDfs(graph, i, postorder, visited, navigation, acc)\n  }\n\n  if (postorder) {\n    acc.push(id)\n  }\n}\n\n/*\n * A helper that preforms a pre- or post-order traversal on the input graph\n * and returns the nodes in the order they were visited. If the graph is\n * undirected then this algorithm will navigate using neighbors. If the graph\n * is directed then this algorithm will navigate using successors.\n *\n * Order must be one of \"pre\" or \"post\".\n */\nexport default function dfs<T extends string>(graph: Graph<T>, ids: T[] | T, order: 'pre' | 'post') {\n  if (!Array.isArray(ids)) {\n    ids = []\n  }\n\n  const navigation = (graph.directed ? graph.successors : graph.neighbors).bind(graph);\n\n  const acc: T[] = [];\n  const visited = {} as Record<T, true>\n\n  for (const id of ids) {\n    if (!graph.hasNode(id)) {\n      throw new Error(`Graph does not have node with id ${id}`)\n    }\n\n    doDfs(graph, id, order === 'post', visited, navigation, acc)\n  }\n\n  return acc;\n}","import Graph from \"@/Graph\"\nimport dfs from './dfs'\n\nexport default function postorder<T extends string>(graph: Graph<T>, ids: T[]) {\n  return dfs(graph, ids, 'post')\n}\n","import Graph from \"@/Graph\";\nimport {longestPath} from './util'\nimport { feasibleTree } from \"./feasible-tree\";\nimport postorder from \"@/algorithms/postorder\";\n\n/*\n * Returns true if the edge is in the tree.\n */\nfunction isTreeEdge<T extends string>(tree: Graph<T>, preId: T, id: T) {\n  return tree.hasEdge(preId, id);\n}\n\nfunction dfsAssignLowLim<T extends string>(tree: Graph<T>, visited: Record<T, boolean>, nextLim: number, id: T, parent?: T) {\n  const low = nextLim;\n  const node = tree.node(id);\n\n  visited[id] = true;\n  for (const i of tree.neighbors(id)) {\n    if (!visited[i]) {\n      nextLim = dfsAssignLowLim(tree, visited, nextLim, i, id)\n    }\n  }\n\n  node.low = low;\n  node.lim = nextLim++;\n  if (parent) {\n    node.parent = parent;\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete node.parent;\n  }\n\n  return nextLim;\n}\n\nfunction initLowLimValues<T extends string>(tree: Graph<T>, root?: T) {\n  if (root === undefined) {\n    root = tree.nodeIds[0];\n  }\n  dfsAssignLowLim(tree, {} as Record<T, boolean>, 1, root);\n}\n\n\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\nfunction calcCutValue<T extends string>(tree: Graph<T>, graph: Graph<T>, child: T) {\n  var childLab = tree.node(child);\n  var parent = childLab.parent;\n  // True if the child is on the tail end of the edge in the directed graph\n  var childIsTail = true;\n  // The graph's view of the tree edge we're inspecting\n  var graphEdge = graph.edge(child, parent!);\n  // The accumulated cut value for the edge between this node and its parent\n  var cutValue = 0;\n\n  if (!graphEdge) {\n    childIsTail = false;\n    graphEdge = graph.edge(parent!, child);\n  }\n\n  cutValue = graphEdge.weight;\n\n  for (const edge of graph.nodeEdgeObjects(child)) {\n    const isOutEdge = edge.fromId === child\n    const other = isOutEdge ? edge.toId : edge.fromId\n\n    if (other !== parent) {\n      const pointsToHead = isOutEdge === childIsTail\n      const otherWeight = edge.weight\n\n      cutValue += pointsToHead ? otherWeight : -otherWeight\n      if (isTreeEdge(tree, child, other)) {\n        const otherCutValue = tree.edge(child, other).cutvalue!\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue\n      }\n    }\n  }\n\n  return cutValue;\n}\n\nfunction assignCutValue<T extends string>(tree: Graph<T>, graph: Graph<T>, child: T) {\n  const childLab = tree.node(child);\n  const parent = childLab.parent;\n  tree.edge(child, parent!).cutvalue = calcCutValue(tree, graph, child)\n}\n\n/*\n * Initializes cut values for all edges in the tree.\n */\nfunction initCutValues<T extends string>(tree: Graph<T>, graph: Graph<T>) {\n  var ids = postorder(tree, tree.nodeIds);\n  ids = ids.slice(0, ids.length - 1);\n\n  for (const id of ids) {\n    assignCutValue(tree, graph, id)\n  }\n}\n\nfunction leaveEdge<T extends string>(tree: Graph<T>) {\n  for (const edge of tree.edgeObjects) {\n    if (edge.cutvalue !== undefined && edge.cutvalue < 0) {\n      return edge\n    }\n  }\n}\n\nexport default function networkSimplex<T extends string>(graph: Graph<T>) {\n  // g = simplify(g);\n  longestPath(graph)\n  const tree = feasibleTree(graph);\n  initLowLimValues(tree);\n  initCutValues(tree, graph);\n\n  let e, f;\n  // while ((e = leaveEdge(tree))) {\n  //   f = enterEdge(t, g, e);\n  //   exchangeEdges(t, g, e, f);\n  // }\n}","import Graph from \"@/Graph\";\nimport networkSimplex from \"./rank/network-simplex\";\n\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\nexport default function rank<T extends string>(graph: Graph<T>) {\n  switch(graph.graph?.ranker) {\n    case \"network-simplex\": networkSimplex(graph); break;\n    // case \"tight-tree\": tightTreeRanker(g); break;\n    // case \"longest-path\": longestPathRanker(g); break;\n    default: networkSimplex(graph);\n  }\n}","import Graph from \"@/Graph\";\n\nexport function maxRank<T extends string>(graph: Graph<T>) {\n  return Math.max(...graph.nodeObjects.map(n => n.rank ?? 0))\n}\n\nexport function buildLayerMatrix<T extends string>(graph: Graph<T>) {\n  const layering: T[][] = []\n  \n  for (let i = 0; i < maxRank(graph) + 1; i++) {\n    layering.push([])\n  }\n\n  for (const id of graph.nodeIds) {\n    const node = graph.node(id)\n    const rank = node.rank\n\n    if (rank !== undefined) {\n      layering[rank][node.order] = id\n    }\n  }\n\n  return layering\n}","import Graph, {Node} from \"@/Graph\";\n\n/*\n * Assigns an initial order value for each node by performing a DFS search\n * starting from nodes in the first rank. Nodes are assigned an order in their\n * rank as they are first visited.\n *\n * This approach comes from Gansner, et al., \"A Technique for Drawing Directed\n * Graphs.\"\n *\n * Returns a layering matrix with an array per layer and each layer sorted by\n * the order of its nodes.\n */\nexport default function initOrder<T extends string>(graph: Graph<T>) {\n  const visited = {} as Record<T, true>\n\n  const nodesWithoutChildren = graph.nodeObjects.filter(node => !Object.keys(node.children).length)\n  const maxRank = Math.max(...nodesWithoutChildren.map(node => node.rank ?? 0))\n  const layers: T[][] = []\n\n  for (let i = 0; i < maxRank + 1; i++) {\n    layers.push([])\n  }\n\n  function dfs(node: Node<T>) {\n    if (visited[node.id]) {\n      return\n    }\n\n    visited[node.id] = true\n    layers[node.rank ?? 0].push(node.id)\n\n    for (const successor of graph.successors(node.id)) {\n      dfs(graph.node(successor))\n    }\n  }\n\n  const orderedNodes = nodesWithoutChildren.sort((a, b) =>( a.rank ?? 0) - (b.rank ?? 0))\n\n  for (const node of orderedNodes) {\n    dfs(node)\n  }\n\n  return layers\n}\n","import Graph from \"@/Graph\";\nimport { maxRank } from \"./util\";\nimport initOrder from \"./order/initOrder\";\n\nfunction assignOrder<T extends string>(graph: Graph<T>, layering: T[][]) {\n  for (const layer of layering) {\n    for (const order in layer) {\n      if (layer.hasOwnProperty(order)) {\n        graph.node(layer[order]).order = Number(order)\n      }\n    }\n  }\n}\n\nexport default function order<T extends string>(graph: Graph<T>) {\n  const rank = maxRank(graph)\n\n  const layering = initOrder(graph)\n\n  assignOrder(graph, layering)\n}","import Graph from \"@/Graph\";\nimport { buildLayerMatrix } from \"./util\";\n\n// function balance(xss, align) {\n\n// }\n\nfunction positionX<T extends string>(graph: Graph<T>) {\n  const layering = buildLayerMatrix(graph)\n\n  const xss = {}\n\n  for (const vertical of ['u', 'd']) {\n    for (const horizontal of ['l', 'r']) {\n      // const xs = \n      // xss[vertical + horizontal] = xs\n    }\n  }\n\n  return\n}\n\nfunction positionY<T extends string>(graph: Graph<T>) {\n  var layers = buildLayerMatrix(graph);\n  var rankSep = /*graph.graph?.ranksep*/ 0;\n  var prevY = 0;\n\n  console.log('vertical layer matrix', layers)\n\n  for (const layer of layers) {\n    const maxHeight = Math.max(...layer.map(id => graph.node(id).height))\n    for (const id of layer) {\n      graph.node(id).y = prevY + maxHeight / 2\n    }\n    prevY += maxHeight + rankSep\n  }\n}\n\nexport default function position<T extends string>(graph: Graph<T>) {\n\n  positionY(graph)\n  // for (const iterator of positionX(graph)) {\n    \n  // }\n}","import Graph from \"./Graph\"\nimport rank from \"./layout/rank\"\nimport order from \"./layout/order\"\nimport position from \"./layout/position\"\n\nexport default function layout<T extends string>(graph: Graph<T>) {\n  // const layoutGraph = buildLayoutGraph(graph)\n  _layout(graph)\n  // updateInputGraph(graph, layoutGraph)\n}\n\nfunction _layout<T extends string>(graph: Graph<T>) {\n  rank(graph)\n  order(graph)\n  position(graph)\n  // translateGraph(graph)\n\n}\n\n/*\n * This idea comes from the Gansner paper: to account for edge labels in our\n * layout we split each rank in half by doubling minlen and halving ranksep.\n * Then we can place labels at these mid-points between nodes.\n *\n * We also add some minimal padding to the width to push the label for the edge\n * away from the edge itself a bit.\n */\n// function makeSpaceForEdgeLabels<T extends string>(g: Graph<T>) {\n//   const graph = g.graph\n//   graph.ranksep /= 2\n\n//   for (const e of g.edgeIds) {\n//     const edge = g.edge(e)\n//   }\n\n//   _.forEach(g.edges(), function (e) {\n//     const edge = g.edge(e)\n//     edge.minlen *= 2\n//     if (edge.labelpos.toLowerCase() !== 'c') {\n//       if (graph.rankdir === 'TB' || graph.rankdir === 'BT') {\n//         edge.width += edge.labeloffset\n//       } else {\n//         edge.height += edge.labeloffset\n//       }\n//     }\n//   })\n// }","import { Selection } from \"d3\";\nimport Graph from './Graph'\nimport { createNodes, positionNodes } from \"./render/nodes\";\nimport layout from \"./layout\";\n\nexport class Renderer<T extends string> {\n\n  graph: Graph<T>\n\n  constructor(graph: Graph<T>) {\n    this.graph = graph\n  }\n\n  preprocess() {\n    for (const id of this.graph.nodeIds) {\n      const node = this.graph.node(id)\n      console.log('TODO: do pre-processing.')\n    }\n  }\n  \n  render(element: Selection<any, any, any, any>, graph: Graph<T>) {\n    // delete everything from element\n    element.selectAll().remove()\n\n    const nodes = createNodes(element.append('g').attr('class', 'nodes'), graph)\n    layout(graph)\n    positionNodes(nodes, graph)\n  }\n\n  // createOrSelectGroup(root, name) {\n  //   let selection = root.select('g.' + name)\n  //   if (selection.empty()) {\n  //     selection = root.append('g').attr('class', name)\n  //   }\n  //   return selection\n  // }\n}","// import * as d3Renderer from 'dagre-d3-renderer'\n// import Graph from './Graph'\nimport {FlowElement, FlowElementEdgeOptions} from './FlowElement'\nimport {select} from 'd3-selection'\nimport Graph, { NodeOptions } from './Graph'\nimport { Renderer } from './Renderer'\n\nexport interface FlowChartElementOptions {\n  label?: string\n}\n\nexport interface FlowChartOptions {\n  direction: 'LR' | 'TB' | 'BT' | 'RL'\n}\n\nexport default class FlowChart {\n  options: FlowChartOptions = {\n    direction: 'LR'\n  }\n  elements: FlowElement[] = []\n\n\n  constructor(options?: FlowChartOptions) {\n    this.options = Object.assign(this.options, options)\n  }\n\n  addElement(id: string, options?: FlowChartElementOptions) {\n    console.log('add element')\n    const el = new FlowElement(id, options)\n    this.elements.push(el)\n    return el\n  }\n\n  destroy() {\n    this.elements.forEach((element) => { element.unregister() })\n  }\n\n  render(element: HTMLElement) {\n    const svg = select(element)\n      .append('svg')\n      .attr('id', 'f' + element.id)\n      .attr('xmlns', 'http://www.w3.org/2000/svg')\n      .attr('width', 1000)\n      .attr('height', 600)\n\n    const svgGroup = svg.append('g')\n\n\n    // Create the input graph\n    const g = new Graph({\n      multigraph: true,\n      compound: true\n    })\n      .setGraph({\n        rankdir: this.options.direction,\n        marginx: 20,\n        marginy: 20\n      })\n      // .setDefaultEdgeLabel(function () {\n      //   return {}\n      // })\n\n    // first create all nodes\n    for (const i in this.elements) {\n      const el = this.elements[i]\n      const elData: NodeOptions = {\n        label: el.id,\n        rx: 5,\n        ry: 5\n      }\n\n      if (el.options?.label) {\n        elData.label = el.options.label\n      }\n      g.setNode(el.id, elData)\n    }\n\n    for (const el of this.elements) {\n      // now create all edges\n      for (const k in el.edges) {\n        const edge = el.edges[k]\n        const edgeData: FlowElementEdgeOptions = {}\n  \n        if (edge.options && edge.options.label) {\n          edgeData.label = edge.options.label\n        }\n  \n        g.setEdge(el.id, edge.otherId, edgeData)\n      }\n    }\n\n    const renderer = new Renderer(g)\n\n    const e = select('#f' + element.id + ' g')\n    renderer.render(e, g)\n    const svgElement = document.getElementById('f' + element.id)\n\n    // now add the listeners after render\n    // e.selectAll('g.node')\n    //   .each(function(v) {\n    //     // get the flow element from the id\n    //     const el = FlowElement.getById(v as string)\n\n    //     if (!el) {\n    //       throw new Error('Element with id ' + v + ' is not defined!')\n    //     }\n\n    //     const d3Node = select(this)\n\n    //     // now loop all listeners\n    //     for (const listener of el.listeners) {\n    //       d3Node.on(listener.event, listener.callback)\n    //     }\n    //   })\n\n    if (!svgElement) {\n      throw new Error('svgElement is null!')\n    }\n\n    const groupElement = svgElement.querySelector('g')\n\n    if (!groupElement) {\n      throw new Error('groupElement is null!')\n    }\n\n    svgElement.setAttribute('width', (groupElement.getBoundingClientRect().width + 40).toString())\n    svgElement.setAttribute('height', (groupElement.getBoundingClientRect().height + 40).toString())\n  }\n}"],"names":[],"mappings":"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"}